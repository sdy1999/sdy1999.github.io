<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sun</title>
  
  
  <link href="https://sdy1999.github.io/atom.xml" rel="self"/>
  
  <link href="https://sdy1999.github.io/"/>
  <updated>2021-04-02T03:11:56.092Z</updated>
  <id>https://sdy1999.github.io/</id>
  
  <author>
    <name>Sun DongYue</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-041：缺失的第一个正数</title>
    <link href="https://sdy1999.github.io/2019/05/24/leetcode-041/"/>
    <id>https://sdy1999.github.io/2019/05/24/leetcode-041/</id>
    <published>2019-05-24T13:23:34.000Z</published>
    <updated>2021-04-02T03:11:56.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p>问哈uiuh</p><p>单位让你2</p><p>2你上次打我【‘</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;问哈uiuh&lt;/p&gt;
&lt;p&gt;单位让你2&lt;/p&gt;
&lt;p&gt;2你上次打我【‘&lt;/p&gt;
</summary>
      
    
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/categories/leetcode-数组/"/>
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/tags/leetcode-数组/"/>
    
    <category term="leetcode-困难" scheme="https://sdy1999.github.io/tags/leetcode-困难/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-040：组合总和2</title>
    <link href="https://sdy1999.github.io/2019/05/24/leetcode-040/"/>
    <id>https://sdy1999.github.io/2019/05/24/leetcode-040/</id>
    <published>2019-05-24T13:23:15.000Z</published>
    <updated>2019-05-24T13:53:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></p><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p><p><strong>说明：</strong></p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>本题相较于上一题仅多约定了使用每个元素只能使用一次，所以仅需修改一下上题的代码，在递归调用时传参i改为i+1即可。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(candidates.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//减掉比target大的数，用于缩小查找时间</span></span><br><span class="line">        <span class="keyword">int</span> end = candidates.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &gt; <span class="number">0</span> &amp;&amp; candidates[end] &gt; target)&#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solution;</span><br><span class="line">        combinationSum2next(candidates,solution,result,<span class="number">0</span>,end,target);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combinationSum2next</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solution,    </span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            result.push_back(solution);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i &gt; start &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(candidates[i] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            solution.push_back(candidates[i]);</span><br><span class="line">            <span class="comment">//相比上题仅修改了此处的参数</span></span><br><span class="line">            combinationSum2next(candidates,solution,result,i+<span class="number">1</span>,end,target -</span><br><span class="line">                                candidates[i]);</span><br><span class="line">            solution.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接：&quot;&gt;&lt;a href=&quot;#题目链接：&quot; class=&quot;headerlink&quot; title=&quot;题目链接：&quot;&gt;&lt;/a&gt;题目链接：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum-</summary>
      
    
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/categories/leetcode-数组/"/>
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/tags/leetcode-数组/"/>
    
    <category term="leetcode-中等" scheme="https://sdy1999.github.io/tags/leetcode-中等/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-039：组合总数</title>
    <link href="https://sdy1999.github.io/2019/05/24/leetcode-039/"/>
    <id>https://sdy1999.github.io/2019/05/24/leetcode-039/</id>
    <published>2019-05-24T13:22:46.000Z</published>
    <updated>2019-05-24T13:40:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></p><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的数字可以无限制重复被选取。</p><p><strong>说明：</strong></p><ul><li>所有数字（包括 <code>target</code>）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>​    很清晰的一个递归题目，通过递归即可求解，注意数组中所有比target的数都没有任何作用，所以先将数组排序，然后去除所有比target大的数，这样可以很大的缩短运行时间</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combinationSumnew</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; solution,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candidates,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//说明此时的solution中的组合不满足</span></span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到了一组solution</span></span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            result.push_back(solution);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candidates[i] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            solution.push_back(candidates[i]);</span><br><span class="line">            <span class="comment">//递归调用</span></span><br><span class="line">            combinationSumnew(result,solution,candidates,i,end,target-candidates[i]);</span><br><span class="line">            solution.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;  result;       </span><br><span class="line">        <span class="keyword">if</span>(candidates.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        <span class="comment">//剪掉所有比target大的数</span></span><br><span class="line">        <span class="keyword">int</span> end = candidates.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(end &gt; <span class="number">0</span> &amp;&amp; candidates[end] &gt; target)&#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solution;</span><br><span class="line">        combinationSumnew(result,solution,candidates,<span class="number">0</span>,end,target);</span><br><span class="line">        <span class="keyword">return</span> result;    </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum/&quot; ta</summary>
      
    
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/categories/leetcode-数组/"/>
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/tags/leetcode-数组/"/>
    
    <category term="leetcode-中等" scheme="https://sdy1999.github.io/tags/leetcode-中等/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-035：搜索插入位置</title>
    <link href="https://sdy1999.github.io/2019/05/24/leetcode-035/"/>
    <id>https://sdy1999.github.io/2019/05/24/leetcode-035/</id>
    <published>2019-05-24T13:22:31.000Z</published>
    <updated>2019-05-24T13:34:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><p><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></p><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>很简单的一个二分查找。。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接：&quot;&gt;&lt;a href=&quot;#题目链接：&quot; class=&quot;headerlink&quot; title=&quot;题目链接：&quot;&gt;&lt;/a&gt;题目链接：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-insert-po</summary>
      
    
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/categories/leetcode-数组/"/>
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/tags/leetcode-数组/"/>
    
    <category term="leetcode-简单" scheme="https://sdy1999.github.io/tags/leetcode-简单/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-034：在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="https://sdy1999.github.io/2019/05/24/leetcode-034/"/>
    <id>https://sdy1999.github.io/2019/05/24/leetcode-034/</id>
    <published>2019-05-24T13:06:07.000Z</published>
    <updated>2019-05-24T13:21:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p><p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>这题没啥意思，就是个二分查找…找到一个target向两边拓展就行了。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//前两个if用于缩短查找时间（专针对leetcode的测试用例）</span></span><br><span class="line">        <span class="keyword">if</span>(nums.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result =&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>]==target)&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(<span class="number">-1</span>);</span><br><span class="line">            ans.push_back(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid;</span><br><span class="line">                r = mid;</span><br><span class="line">                <span class="keyword">while</span>(l &gt; <span class="number">0</span> &amp;&amp; nums[l<span class="number">-1</span>] == target)&#123;</span><br><span class="line">                    l--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(r &lt; len - <span class="number">1</span>  &amp;&amp; nums[r+<span class="number">1</span>] == target)&#123;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result =&#123;l,r&#125;;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result =&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接：&quot;&gt;&lt;a href=&quot;#题目链接：&quot; class=&quot;headerlink&quot; title=&quot;题目链接：&quot;&gt;&lt;/a&gt;题目链接：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-first-and-l</summary>
      
    
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/categories/leetcode-数组/"/>
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/tags/leetcode-数组/"/>
    
    <category term="leetcode-中等" scheme="https://sdy1999.github.io/tags/leetcode-中等/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-033：搜索旋转排序数组</title>
    <link href="https://sdy1999.github.io/2019/05/24/leetcode-033/"/>
    <id>https://sdy1999.github.io/2019/05/24/leetcode-033/</id>
    <published>2019-05-24T12:31:11.000Z</published>
    <updated>2019-05-24T12:55:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></p><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>​        这题也很有意思，做了这个题我发现原来不是只有严格有序的数组才能用二分查找法，而像这种二分后必有一半是有序数组的奇奇怪怪的数组也能用二分查找法。</p><p>​        要求时间复杂度为O(log n) ，又为查找问题，所以肯定会和二分查找有关系。</p><p>​        首先分析一下旋转后的数组，我们可以发现，无论这个数组是在哪个点旋转的，二分后总会有一边是严格有序的。所以可以通过判断target是否在这个严格有序的区间内来区分二分的操作，代码如下：</p><p>ps:想不明白看看代码就明白了。。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = len <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//找到了</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//尚未找到，确定下次二分的区间</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[l])&#123;</span><br><span class="line">                <span class="comment">//说明此时mid左侧为有序的</span></span><br><span class="line">                <span class="keyword">if</span>(target &lt; nums[mid] &amp;&amp; nums[l] &lt;= target)&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//此时mid右侧为有序的</span></span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; nums[r] &gt;= target)&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;     </span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接：&quot;&gt;&lt;a href=&quot;#题目链接：&quot; class=&quot;headerlink&quot; title=&quot;题目链接：&quot;&gt;&lt;/a&gt;题目链接：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotate</summary>
      
    
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/categories/leetcode-数组/"/>
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/tags/leetcode-数组/"/>
    
    <category term="leetcode-中等" scheme="https://sdy1999.github.io/tags/leetcode-中等/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-031：下一个排列</title>
    <link href="https://sdy1999.github.io/2019/05/24/leetcode-031/"/>
    <id>https://sdy1999.github.io/2019/05/24/leetcode-031/</id>
    <published>2019-05-24T11:43:05.000Z</published>
    <updated>2021-04-02T03:35:45.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列</a></p><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须<strong>原地</strong>修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>这题挺有意思的，之前未接触过字典序相关的题目，首先介绍一下什么是字典序及其比较：        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">字典序，就是按照字典中出现的先后顺序进行排序。</span><br><span class="line"></span><br><span class="line">给定多个字符，可以按照任意顺序进行排列，所有排列称为全排列。</span><br><span class="line"></span><br><span class="line">每一种排列对应一个字符串，如果这些字符串按照字符串大小的顺序进行排序，那么就这种排序是基于字典序的全排列。</span><br><span class="line"></span><br><span class="line">比如给定三个字符 a,b,c，则他们基于字典序的全排列为：</span><br><span class="line"></span><br><span class="line">abc &gt; acb &gt; bac &gt; bca &gt; cab &gt; cba</span><br></pre></td></tr></table></figure><blockquote><p>注：以上关于字典序的内容引用自：<a href="https://blog.csdn.net/happyrocking/article/details/83619392" target="_blank" rel="noopener">https://blog.csdn.net/happyrocking/article/details/83619392</a> </p></blockquote><p>求解当前字典序的下一个排列：</p><p>假设当前为： 389276431</p><p>​    首先从右向左遍历，直到找到一个num[t] ,这个点满足num[t] &lt; nums[t+1]</p><p>​    随后从右侧端点开始，找到第一个比num[t]大的数 num[r],交换这两个数的值，随后对nums[t]之后的数组进行排序，得到的即为当前字典序的下一个排列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">对于：389273231</span><br><span class="line">首先由第一步从右向左找到第一个满足nums[t] &lt; num[t+1]的数：nums[3] = 2 </span><br><span class="line">然后由第二步从右向左找到第一个满足 nums[r] &gt; nums[3]的数：nums[7] = 2</span><br><span class="line">交换 nums[3] 和 nums[7] 的值 得到字典序： 389373221</span><br><span class="line">随后对nums[3]后的数组进行排序 得到： 389312237</span><br><span class="line">即为原字典序的下一个排列</span><br><span class="line"></span><br><span class="line">关于为什么要从右向左找，为什么要满足这个条件？</span><br><span class="line">其实这点很好理解，但是文字不太好描述，所以我结合我的理解说一下，可能说不太清楚：</span><br><span class="line">字典序的比较类似于两个整数之间的比较，比如两个三位数比较肯定是先比较百位，再比较十位，最后才比较个位，所以求一个三位数的下一个数肯定是先在个位上进行变化，求字典序的下一个排列也是如此，从右边开始，对第一个可以变大的值进行替换，可以满足求到新排列为最接近原字典序的排列，其他的地方应该都很好理解。</span><br></pre></td></tr></table></figure><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> left = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = left <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] &lt; nums[right+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//当前字典序已经是最大的了</span></span><br><span class="line">            sort(nums.begin(),nums.end());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &gt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left] &gt; nums[right])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums[left],nums[right]);</span><br><span class="line">            sort(nums.begin()+right+<span class="number">1</span>,nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以对上面代码进行一些优化，将排序的操作提前，这样可以缩短寻找left的时间，但优化后跑的速度差不多，可能是因为样例规模太小</p><p>优化后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//迭代器可用可不用，排序时可以像上面一样用nums.end() - ___ 代替</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pos_i = nums.end()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] &lt; nums[right+<span class="number">1</span>])&#123;</span><br><span class="line">                sort(pos_i,nums.end());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pos_i--;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">-1</span>)&#123;</span><br><span class="line">            sort(nums.begin(),nums.end());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> left = right;</span><br><span class="line">            <span class="keyword">while</span>(left++ &lt; len <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left] &gt; nums[right])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums[left],nums[right]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/next-permutation/&quot; t</summary>
      
    
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/categories/leetcode-数组/"/>
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/tags/leetcode-数组/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-027：移除元素</title>
    <link href="https://sdy1999.github.io/2019/05/24/leetcode-027/"/>
    <id>https://sdy1999.github.io/2019/05/24/leetcode-027/</id>
    <published>2019-05-24T11:32:23.000Z</published>
    <updated>2019-05-24T13:48:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><p><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">27. 移除元素</a></p><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>给定一个数组 <em>nums</em> 和一个值 <em>val</em>，你需要<strong>原地</strong>移除所有数值等于 <em>val</em> 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>题目很简单，没什么难理解的地方，还是用一个指针 pos  记录下“新数组”的尾部，然后遍历数组，将不为val的值填入新数组就可以了</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">                nums[pos++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接：&quot;&gt;&lt;a href=&quot;#题目链接：&quot; class=&quot;headerlink&quot; title=&quot;题目链接：&quot;&gt;&lt;/a&gt;题目链接：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-element/&quot;</summary>
      
    
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/categories/leetcode-数组/"/>
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/tags/leetcode-数组/"/>
    
    <category term="leetcode-简单" scheme="https://sdy1999.github.io/tags/leetcode-简单/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-026：删除排序数组中的重复项</title>
    <link href="https://sdy1999.github.io/2019/05/24/leetcode-026/"/>
    <id>https://sdy1999.github.io/2019/05/24/leetcode-026/</id>
    <published>2019-05-24T11:02:56.000Z</published>
    <updated>2019-05-24T11:30:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></p><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>这题比较简单，用两个指针，一个用于遍历，一个用于存储“新数组”的尾巴即可。我一直开始想的是一个指针从头开始，一个指针从尾开始，但是处理起来很麻烦很麻烦，后来看了别人的代码才明白自己走歪了，，，</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fisrt记录新数组的插入位置，follow用于遍历</span></span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>,follow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(follow != len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[follow] != nums[first])&#123;</span><br><span class="line">                nums[++first] = nums[follow];</span><br><span class="line">            &#125;</span><br><span class="line">            follow++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first+<span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接：&quot;&gt;&lt;a href=&quot;#题目链接：&quot; class=&quot;headerlink&quot; title=&quot;题目链接：&quot;&gt;&lt;/a&gt;题目链接：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicate</summary>
      
    
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/categories/leetcode-数组/"/>
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/tags/leetcode-数组/"/>
    
    <category term="leetcode-简单" scheme="https://sdy1999.github.io/tags/leetcode-简单/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-018：四数之和</title>
    <link href="https://sdy1999.github.io/2019/05/24/leetcode-018/"/>
    <id>https://sdy1999.github.io/2019/05/24/leetcode-018/</id>
    <published>2019-05-24T10:44:20.000Z</published>
    <updated>2019-05-24T14:00:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><p><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></p><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 <em>a，**b，c</em> 和 <em>d</em> ，使得 <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>​        思路类似<a href="https://sdy1999.github.io/2019/05/18/leetcode-015/">leetcode_015：三数之和</a>，在求三数之和的基础上再加一层循环变为求四数之和即可，关于去重和剪枝的操作注释都放在代码里，不详细说明了，若对去重或是双指针遍历不太了解可以看一下上面的链接，在那篇博客里说的很详细。本题要注意的地方就是对节点剪枝优化可以大大的缩短程序的运行时间</p><h2 id="相关的题目："><a href="#相关的题目：" class="headerlink" title="相关的题目："></a>相关的题目：</h2><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//思路就是将求四数之和转变为求三数之和，再将求三数之和转变为求两数之和，然后使用双指针遍历</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-3</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//剪枝优化</span></span><br><span class="line">            <span class="keyword">if</span>((num[i] + nums[len<span class="number">-1</span>] + nums[len<span class="number">-2</span>] + nums[len<span class="number">-3</span>])&lt; target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>]) &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len<span class="number">-2</span>; j++)&#123;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt; i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//剪枝优化</span></span><br><span class="line">                <span class="keyword">if</span>((num[i] + nums[j] + nums[len<span class="number">-1</span>] + nums[len<span class="number">-2</span>])&lt; target)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((nums[i] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] + nums[j]) &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = len <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = &#123;nums[i],nums[j],nums[left],nums[right]&#125;;</span><br><span class="line">                        result.push_back(t);</span><br><span class="line"><span class="comment">//去重</span></span><br><span class="line">                        <span class="keyword">while</span>(left + <span class="number">1</span> &lt; right &amp;&amp; nums[left] == nums[left +<span class="number">1</span>])&#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right<span class="number">-1</span> &amp;&amp; nums[right] == nums[right<span class="number">-1</span>])&#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="相似的题目："><a href="#相似的题目：" class="headerlink" title="相似的题目："></a>相似的题目：</h1><p><a href="https://sdy1999.github.io/2019/05/18/leetcode-015/">leetcode_015：三数之和</a></p><p><a href="https://sdy1999.github.io/2019/05/24/leetcode-018/">leetcode-018：四数之和</a></p><p><a href="https://sdy1999.github.io/2019/05/24/leetcode-016/">leetcode-016：最接近的三数之和</a></p><p><a href="https://sdy1999.github.io/2019/05/24/leetcode-001/">leetcode-001：两数之和</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接：&quot;&gt;&lt;a href=&quot;#题目链接：&quot; class=&quot;headerlink&quot; title=&quot;题目链接：&quot;&gt;&lt;/a&gt;题目链接：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/4sum/&quot; target=&quot;_</summary>
      
    
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/categories/leetcode-数组/"/>
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/tags/leetcode-数组/"/>
    
    <category term="leetcode-中等" scheme="https://sdy1999.github.io/tags/leetcode-中等/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-016：最接近的三数之和</title>
    <link href="https://sdy1999.github.io/2019/05/24/leetcode-016/"/>
    <id>https://sdy1999.github.io/2019/05/24/leetcode-016/</id>
    <published>2019-05-24T10:26:30.000Z</published>
    <updated>2019-05-24T14:00:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></p><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</span><br><span class="line"></span><br><span class="line">与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>​        此题思路类似 <a href="https://sdy1999.github.io/2019/05/18/leetcode-015/">leetcode_015：三数之和</a>，但不同的是，本题最接近的三数之和肯定只有一组数据，所以比起上面的求三数之和的题目无需考虑去重的问题，但整体思路类似，将求三数之和的问题转换成求两数之和，用双指针遍历求解即可。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//注意双指针遍历一定要先排序</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> close = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//转换成两数之和</span></span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = len <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">int</span> s = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(s == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> s;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(s - target) &lt; <span class="built_in">abs</span>(close - target))&#123;</span><br><span class="line">                    close = s;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(s - target &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> close;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="相似的题目："><a href="#相似的题目：" class="headerlink" title="相似的题目："></a>相似的题目：</h1><p><a href="https://sdy1999.github.io/2019/05/18/leetcode-015/">leetcode_015：三数之和</a></p><p><a href="https://sdy1999.github.io/2019/05/24/leetcode-018/">leetcode-018：四数之和</a></p><p><a href="https://sdy1999.github.io/2019/05/24/leetcode-016/">leetcode-016：最接近的三数之和</a></p><p><a href="https://sdy1999.github.io/2019/05/24/leetcode-001/">leetcode-001：两数之和</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum-closest/&quot; targe</summary>
      
    
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/categories/leetcode-数组/"/>
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/tags/leetcode-数组/"/>
    
    <category term="leetcode-中等" scheme="https://sdy1999.github.io/tags/leetcode-中等/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-011：盛最多水的容器</title>
    <link href="https://sdy1999.github.io/2019/05/24/leetcode-011/"/>
    <id>https://sdy1999.github.io/2019/05/24/leetcode-011/</id>
    <published>2019-05-24T09:50:21.000Z</published>
    <updated>2019-05-24T13:51:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></p><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>给定 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>​    设两条边分别为   (i , $a_i$) , (j , $a_j$)，我们取 L = min( $a_i$ , $a_j$ ), 可以发现 S = L * abs( j -  i ) ,即 S与较高的那条边的高度无关。 因此这道题本质上还是一个双指针遍历，即由较短的边向内推进，然后判断面积的变化(应该不难理解。。)。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> area,maxarea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = height.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = min(height[left],height[right]);</span><br><span class="line">            maxarea = max(maxarea,t*(right-left));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxarea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接：&quot;&gt;&lt;a href=&quot;#题目链接：&quot; class=&quot;headerlink&quot; title=&quot;题目链接：&quot;&gt;&lt;/a&gt;题目链接：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-m</summary>
      
    
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/categories/leetcode-数组/"/>
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/tags/leetcode-数组/"/>
    
    <category term="leetcode-中等" scheme="https://sdy1999.github.io/tags/leetcode-中等/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-001：两数之和</title>
    <link href="https://sdy1999.github.io/2019/05/24/leetcode-001/"/>
    <id>https://sdy1999.github.io/2019/05/24/leetcode-001/</id>
    <published>2019-05-24T09:29:20.000Z</published>
    <updated>2019-05-24T13:58:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></p><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>本题有好多种解法，可以暴力破解或者使用hash_map等解法，记录下hash_map 和双指针遍历的解法和代码，本来还想试一下双指针遍历，但双指针遍历需要先将数组进行排序，这样会丢失原来的下标导致只能找到数而无法找到数的位置，为了记录原来的下标再使用新的内存有点得不偿失，所以没有使用双指针遍历。</p><h2 id="使用hash-map"><a href="#使用hash-map" class="headerlink" title="使用hash_map:"></a>使用hash_map:</h2><p>因为本题不难，所以只放一下代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.find(nums[i]) == m.end())&#123;</span><br><span class="line">                 m[target - nums[i]] = i; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.push_back(m[nums[i]]);</span><br><span class="line">                result.push_back(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="相似的题目："><a href="#相似的题目：" class="headerlink" title="相似的题目："></a>相似的题目：</h1><p><a href="https://sdy1999.github.io/2019/05/18/leetcode-015/">leetcode_015：三数之和</a></p><p><a href="https://sdy1999.github.io/2019/05/24/leetcode-018/">leetcode-018：四数之和</a></p><p><a href="https://sdy1999.github.io/2019/05/24/leetcode-016/">leetcode-016：最接近的三数之和</a></p><p><a href="https://sdy1999.github.io/2019/05/24/leetcode-001/">leetcode-001：两数之和</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接：&quot;&gt;&lt;a href=&quot;#题目链接：&quot; class=&quot;headerlink&quot; title=&quot;题目链接：&quot;&gt;&lt;/a&gt;题目链接：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum/&quot; target</summary>
      
    
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/categories/leetcode-数组/"/>
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/tags/leetcode-数组/"/>
    
    <category term="leetcode-简单" scheme="https://sdy1999.github.io/tags/leetcode-简单/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-015：三数之和</title>
    <link href="https://sdy1999.github.io/2019/05/18/leetcode-015/"/>
    <id>https://sdy1999.github.io/2019/05/18/leetcode-015/</id>
    <published>2019-05-18T02:13:22.000Z</published>
    <updated>2019-05-24T13:59:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接:"></a>题目链接:</h1><p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. <strong>三数之和</strong></a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h1><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>​             原本思路是通过一个for循环，每次循环时固定a的值，将a+b+c = 0 的问题 转变为 每次循环，找到所有满足 b+c = -a 的不重复的{b,c}组合，而寻找两数之和时可以采用之前题目使用的方法，使用hash_map来优化时间复杂度，但这样的话去重复的问题会很难解决，所以在开始首先对整个nums[] 数组使用sort()函数排序，具体去重的操作贴在下面的代码，但使用hash_map会超时，就算引入了剪枝优化等操作还是会超时，所以弃用了hash_map,改用了双指针遍历。但还是贴上了使用hash_map的思路作为一个记录</p><h2 id="思路一：使用hash-map"><a href="#思路一：使用hash-map" class="headerlink" title="思路一：使用hash_map"></a>思路一：使用hash_map</h2><p><strong>注意： 这种方法不满足题目运行时间要求，仅仅作为一个思路的记录，满足要求的程序在双指针遍历，可以直接看那个</strong></p><h3 id="hash-map去重的方式"><a href="#hash-map去重的方式" class="headerlink" title="hash_map去重的方式:"></a>hash_map去重的方式:</h3><p>​    去重思路有两种：一个是直接略去寻找相同的三元组的操作，</p><p>​                            另一个是对每个三元组判断是否result中存在相同的三元组</p><p>第一种思路的耗时比第二种少（虽然两种办法都会超时）</p><p>首先说一下我使用hash_map的方法，然后在结合代码说一下我去重的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">对于数组nums,假设已经固定好num[i],现在要在nums[i+<span class="number">1</span>,i+<span class="number">2</span>,..]中寻找b,c满足 b+c =  -a:</span><br><span class="line">使用hash_map存放某个点渴望的得到的值</span><br><span class="line">例如 m[y] = j 表示 nums[j] 渴望得到 y 来满足 nums[j] + y  = -nums[i]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.size()<span class="number">-1</span>; j++)&#123;</span><br><span class="line">    <span class="comment">// y为当前的点为了满足 nums[i] +num[j] + c = 0 所渴望找到的c的值</span></span><br><span class="line">    <span class="keyword">int</span>  y = -nums[i] - nums[j];</span><br><span class="line">    <span class="comment">//首先判断当前的点的值 是否 为之前的点所渴望的值，若不是，则将当前点存入map中便于后续点查询</span></span><br><span class="line">    <span class="keyword">if</span>(m.find(nums[j]) == m.end())&#123;</span><br><span class="line">        m[y] = j;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//若是，则说明找到了一对&#123;a,b,c&#125;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = &#123;nums[i],nums[j],y&#125;;</span><br><span class="line">        result.push_back(t);            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">因为已经提前排序，所以不会出现类似&#123;<span class="number">0</span>，<span class="number">1</span>，<span class="number">1</span>&#125;&#123;<span class="number">1</span>，<span class="number">0</span>，<span class="number">1</span>&#125;顺序颠倒的重复，而仅会出现&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;这种，所以可对a,b,c分别去重：</span><br><span class="line">对 a 进行去重是最简单的，只需要保证相同的值仅遍历一次即可：</span><br><span class="line">添加如下代码：</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) </span><br><span class="line">        <span class="keyword">continue</span>;     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对 b,c 去重操作发生在找到一对&#123;a,b,c&#125;后：</span><br><span class="line"></span><br><span class="line">若是第一种去重方法，因为nums数组已经是排序完毕，所以只需将<span class="keyword">else</span>函数改进一下：</span><br><span class="line"><span class="keyword">if</span>(m.find(nums[j]) == m.end())&#123;</span><br><span class="line">        m[y] = j;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = &#123;nums[i],nums[j],y&#125;;</span><br><span class="line">        result.push_back(t);</span><br><span class="line">        <span class="comment">//只需要保证 b,b,b,b 只与 渴望得到b的c 仅叠加一次即可。</span></span><br><span class="line">        <span class="keyword">while</span>(j+<span class="number">1</span>&lt;nums.size() &amp;&amp; nums[j] == nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">           j++;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    若采用第二种去重方法，也是仅改动<span class="keyword">else</span>函数即可：</span><br><span class="line">    <span class="keyword">if</span>(m.find(nums[j]) == m.end())&#123;</span><br><span class="line">        m[y] = j;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = &#123;nums[i],nums[j],y&#125;;</span><br><span class="line">        sort(t.begin(),t.end());</span><br><span class="line">        <span class="keyword">if</span>(find(result.begin(),result.end(),t) == result.end())&#123;</span><br><span class="line">        result.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">贴上全代码：</span><br><span class="line">ps：这种方法不满足运行时间要求，仅仅是为了记录一下</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="comment">//若输入不足三个数则直接退出</span></span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">//排序，方便后面去重复和剪枝优化</span></span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size()<span class="number">-2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//去重，相同的值遍历一次即可</span></span><br><span class="line">            <span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) </span><br><span class="line">                <span class="keyword">continue</span>;     </span><br><span class="line">            <span class="comment">//剪枝优化，三个正数和不可能为0（建立在已经排序的基础上）</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">            <span class="comment">//若下面的代码不太清楚，可以参考上面的解释</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.size()<span class="number">-1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span>  y = -nums[i] - nums[j];</span><br><span class="line">                <span class="keyword">if</span>(m.find(nums[j]) == m.end())&#123;</span><br><span class="line">                    m[y] = j;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = &#123;nums[i],nums[j],y&#125;;</span><br><span class="line">                    result.push_back(t);</span><br><span class="line">                    <span class="keyword">while</span>(j+<span class="number">1</span>&lt;nums.size() &amp;&amp; nums[j] == nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;                   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="思路二：使用双指针遍历"><a href="#思路二：使用双指针遍历" class="headerlink" title="思路二：使用双指针遍历"></a>思路二：使用双指针遍历</h2><p>因为hash_map的运行时间行不通，所以考虑换一种思路进行 b+c=-a的查找</p><h3 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h3><p>首先还是要对整个<code>nums</code>数组进行排序，这是双指针遍历的基础</p><p>这种方法无论是去重还是总体思路都与上面相同，仅仅是更换了数据结构和查询的推进方式，所以不再累述。</p><p>注意的地方是引入了剪枝优化，大大的缩短了当<code>nums</code>数据量很大时的查询时间。</p><p>引入剪枝优化前：</p><p><img src="/images/before.png" alt></p><p>引入剪枝优化后：</p><p><img src="/images/after.png" alt></p><p>我认为本题之所以使用双指针遍历比hash_map快是因为他可以同时对b,c进行去重，而hash_map仅可以快速对c进行去重，而b的去重是通过不断更新hash_map中对应项的渴望来实现的，所以可能速度较慢。（仅是个人观点，实在想不到为什么hash_map会慢到连提交要求都达不到）</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length<span class="number">-2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//双指针遍历</span></span><br><span class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>,right = nums.size<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//去重复</span></span><br><span class="line">            <span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//剪枝优化，三个正数和不可能为0</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">int</span>  sum = nums[left]+nums[right]+nums[i];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = &#123;nums[i],nums[left],nums[right]&#125;;</span><br><span class="line">                    result.push_back(t);</span><br><span class="line">                    <span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">while</span>(left+<span class="number">1</span> &lt; right &amp;&amp; nums[left+<span class="number">1</span>] == nums[left])&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">while</span>(right<span class="number">-1</span> &lt; left &amp;&amp; nums[right] == nums[right])&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//sum&gt;0  说明此时右端点的数过大</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//sum&lt;0 说明此时左端点的数过小</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="相似的题目："><a href="#相似的题目：" class="headerlink" title="相似的题目："></a>相似的题目：</h1><p><a href="https://sdy1999.github.io/2019/05/18/leetcode-015/">leetcode_015：三数之和</a></p><p><a href="https://sdy1999.github.io/2019/05/24/leetcode-018/">leetcode-018：四数之和</a></p><p><a href="https://sdy1999.github.io/2019/05/24/leetcode-016/">leetcode-016：最接近的三数之和</a></p><p><a href="https://sdy1999.github.io/2019/05/24/leetcode-001/">leetcode-001：两数之和</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接:&quot;&gt;&lt;/a&gt;题目链接:&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/&quot; target=&quot;_bl</summary>
      
    
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/categories/leetcode-数组/"/>
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/tags/leetcode-数组/"/>
    
    <category term="leetcode-中等" scheme="https://sdy1999.github.io/tags/leetcode-中等/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-004：寻找两个有序数组的中位数</title>
    <link href="https://sdy1999.github.io/2019/05/14/leetcode-004/"/>
    <id>https://sdy1999.github.io/2019/05/14/leetcode-004/</id>
    <published>2019-05-14T02:04:26.000Z</published>
    <updated>2019-05-24T10:48:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><h4 id="寻找两个有序数组的中位数"><a href="#寻找两个有序数组的中位数" class="headerlink" title="寻找两个有序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">寻找两个有序数组的中位数</a></h4><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定两个大小为 m 和 n 的有序数组 <code>nums1</code> 和 <code>nums2</code>。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p><p><strong>示例 1:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line">nums2 = [<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">则中位数是 <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">则中位数是 (<span class="number">2</span> + <span class="number">3</span>)/<span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>因要求时间复杂度为 O(log(m + n))，所以考虑采用二分查找的方法来解决这个问题</p><h3 id="定义“割”："><a href="#定义“割”：" class="headerlink" title="定义“割”："></a>定义“割”：</h3><p>首先定义割的概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">我们通过切一刀，能够把有序数组分成左右两个部分，切的那一刀就被称为割(Cut)，割的左右会有两个元素，分别是左边最大值和右边最小值。</span><br><span class="line">我们定义L = Max(LeftPart)，R = Min(RightPart)</span><br><span class="line"></span><br><span class="line">割操作可以割在两个数中间，也可以在一个数上进行：</span><br><span class="line"></span><br><span class="line">如数组 如数组 arr[4] = &#123;0,1,2,3,4,5&#125;</span><br><span class="line">若割在2,3之间，即&#123;0,1,2 | 3,4,5&#125;</span><br><span class="line">   则中值为（2+3）/2  </span><br><span class="line">   </span><br><span class="line">   再如数组 arr[5] = &#123;0,1,2,3,4&#125;</span><br><span class="line">   若割在数字2上，即&#123;0,1,2|2,3,4&#125;</span><br><span class="line">   则中值为（2+2）/2</span><br></pre></td></tr></table></figure><h3 id="通过“割”来找到两个有序数组的第k位数："><a href="#通过“割”来找到两个有序数组的第k位数：" class="headerlink" title="通过“割”来找到两个有序数组的第k位数："></a>通过“割”来找到两个有序数组的第k位数：</h3><p>设$C_i$为当前数组对应的割点</p><p>​    $L_i$为当前数组割点左元素</p><p>​    $R_i$为当前数组割点右元素</p><table><thead><tr><th style="text-align:center">Leftpart</th><th style="text-align:center">$C_i$</th><th style="text-align:center">Rightpart</th></tr></thead><tbody><tr><td style="text-align:center">$a_1,a_2,a_3,…,a_i$</td><td style="text-align:center">i</td><td style="text-align:center">$a_{i+1},a_{i+2},a_{i+3},…,a_n$</td></tr><tr><td style="text-align:center">$b_1,b_2,b_3,…,b_j$</td><td style="text-align:center">j</td><td style="text-align:center">$b_{j+1},b_{j+2},b_{j+3},…,b_m$</td></tr></tbody></table><p>根据割的概念，一定有 $L_1$&lt;= $R_1$ , $L_2$&lt;=$R_2$</p><ol><li><p>若令 $L_1$ &lt;= $R_2$ &amp;&amp; $L_2$&lt;= $R_1$,则说明此时 Leftpart 中的全部元素 &lt;= Rightpart 中的所有元素</p><p>​        若此时左边元素的个数之和为k,则说明此时两个有序数组的第k个数为 max($L_1$,$L_2$);</p></li><li><p>若当前割法不满足 $L_1$ &lt;= $R_2$ &amp;&amp; $L_2$&lt;= $R_1$：</p><p>​    如果$L_1$&gt; $R_2$, 则说明数组a[]的割点左侧元素过多，故需将C1 减小，C2增大</p><p>​    如果$L_2$ &gt; $R_1$, 则说明数组a[]的割点左侧元素过少，故需将C1 增大，C2减小</p></li></ol><p>通过此种方法便可以找到两个有序数组的第k个数</p><h3 id="将第k位数-延申为-中位数："><a href="#将第k位数-延申为-中位数：" class="headerlink" title="将第k位数 延申为 中位数："></a>将第k位数 延申为 中位数：</h3><p>因寻找两个有序数组的第k位数 无需考虑数组的奇偶性，所以将其延申为中位数时需要考虑奇偶性的关系</p><p>因为将两个数组进行 奇偶，偶奇，奇奇，偶偶的情况进行讨论有些麻烦，所以我们希望寻找一种对数组进行虚拟拓展的方法来将操作统一化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">因 <span class="number">2</span>n+<span class="number">1</span> 恒为奇数，所以可以通过：</span><br><span class="line"></span><br><span class="line">a[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;；</span><br><span class="line"></span><br><span class="line">a_tuo[<span class="number">2</span>*<span class="number">4</span> + <span class="number">1</span>] = &#123;#,<span class="number">0</span>,#,<span class="number">1</span>,#,<span class="number">2</span>,#,<span class="number">3</span>,#&#125;；</span><br><span class="line"></span><br><span class="line">此种拓展方式将数组拓展为长度为<span class="number">2</span>n+<span class="number">1</span>的奇数长度的数组</span><br></pre></td></tr></table></figure><p>采用这种拓展方式的好处：</p><ol><li><strong>可以通过简单的数学计算表示相同的元素在数组拓展前后位置的对应关系：</strong><pre><code> 拓展后数组中元素的位置/2 = 原来数组中相应的元素位置例如：</code></pre></li></ol><table><thead><tr><th style="text-align:center">元素值</th><th style="text-align:center">在拓展前数组的位置</th><th style="text-align:center">在拓展后数组的位置</th><th style="text-align:center">位置关系</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">a[3]</td><td style="text-align:center">a[7]</td><td style="text-align:center">7/2 = 3</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">a[1]</td><td style="text-align:center">a_tuo[3]</td><td style="text-align:center">3/2 = 1</td></tr></tbody></table><ol start="2"><li><p><strong>可以很简单统一 割在两个元素之间，和割在一个元素的操作：</strong></p><p>对于数组 a_tuo[2*4 + 1] = ；</p><p>即取割点 $C_i$</p><p>​    若 i =  4，即割点取在1,2之间的 ‘#’上 ，说明此时为割在两个元素之间</p><p>​            $L_i$  =  ($C_i$ -1) /2 = 1;</p><p>​            $R_i$=  $C_i$/2 = 2;</p><p>​    恰好可以映射在原数组的元素1,2对应的位置</p><p>​    若i = 5，即割点取在数字2上，说明此时为割在一个元素上</p><p>​            $L_i$  =  ($C_i$ -1)/2 = 2;</p><p>​            $R_i$  =  $C_i$ /2 = 2;</p><p>​    恰好可以映射在原数组的元素2对应的位置</p><p>即通过此种拓展方法，可以使用$L_i$  = $C_i$-1；$R_i$= $C_i$ ；一套公式统一割点选择不同情况下的操作  </p><p>ps： 因找到了映射关系，所以拓展无需实际上进行，只是虚拟的一步</p></li></ol><p><strong>接下来就可以进行 寻找中位数的操作了：</strong></p><p>​    把2个数组看做一个虚拟的数组A，目前有2m+2n+2个元素，割在m+n+1处，所以我们只需找到m+n+1位置的元素和m+n+2位置的元素就行了。<br>左边：A[m+n+1] = Max($L_1$+$L_2$)<br>右边：A[m+n+2] = Min($R_1$+$R_2$)</p><h3 id="通过二分查找来满足时间复杂度："><a href="#通过二分查找来满足时间复杂度：" class="headerlink" title="通过二分查找来满足时间复杂度："></a>通过二分查找来满足时间复杂度：</h3><p>因为C1 与C2的和为固定的，所以仅需要求出较短的数组对应的C1即可，故我们对较短的数组a[n]进行二分查找：</p><p>二分的方法：</p><p>$L_1$&gt;$R_2$，把C1减小，C2增大。—&gt; C1向左二分 </p><p>$L_2$&gt;$R_1$，把C1增大，C2减小。—&gt; C1向右二分</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> m = nums2.size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//保证第一个数组为较短的数组，用于减少二分查找的时间</span></span><br><span class="line">        <span class="keyword">if</span>(n &gt; m)&#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2,nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> L1,L2,R1,R2,c1,c2,l = <span class="number">0</span>,e = <span class="number">2</span> * n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= e)&#123;</span><br><span class="line">            </span><br><span class="line">            c1 = (l + e) / <span class="number">2</span>;</span><br><span class="line">            c2 = m + n - c1;</span><br><span class="line">            </span><br><span class="line">            L1 = (c1 == <span class="number">0</span>)?INT_MIN:nums1[(c1<span class="number">-1</span>)/<span class="number">2</span>];  </span><br><span class="line">            R1 = (c1 == <span class="number">2</span>*n)?INT_MAX:nums1[c1/<span class="number">2</span>];</span><br><span class="line">            L2 = (c2 == <span class="number">0</span>)?INT_MIN:nums2[(c2<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">            R2 = (c2 == <span class="number">2</span>*m)?INT_MAX:nums2[c2/<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(L1 &gt; R2)&#123;</span><br><span class="line">                e = c1 <span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(L2&gt; R1)&#123;</span><br><span class="line">                l = c1 + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (max(L1,L2)+ min(R1,R2))/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接：&quot;&gt;&lt;a href=&quot;#题目链接：&quot; class=&quot;headerlink&quot; title=&quot;题目链接：&quot;&gt;&lt;/a&gt;题目链接：&lt;/h1&gt;&lt;h4 id=&quot;寻找两个有序数组的中位数&quot;&gt;&lt;a href=&quot;#寻找两个有序数组的中位数&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/categories/leetcode-数组/"/>
    
    
    <category term="leetcode-数组" scheme="https://sdy1999.github.io/tags/leetcode-数组/"/>
    
    <category term="leetcode-困难" scheme="https://sdy1999.github.io/tags/leetcode-困难/"/>
    
  </entry>
  
</feed>
